#  8.3 Code: Buffer cache

块缓冲是缓冲区的双向链表。`main`函数（`kernel/main.c:27`）中调用的 `binit`函数，会从一个静态数组 `buf` 中构建出一个有 `NBUF` 个元素的双向链表（`kernel/bio.c:43-52`）。后续所有对块缓冲的访问都通过链表（`bcache.head`）而非静态数组。

缓存区通过两个字段来表示其状态，`valid` 表示当前的缓存区持有某个block的拷贝，`device`表示缓冲区内容已经交给磁盘，可能会改变缓冲区（比如，write data from the disk into data）。

`Bread`（`kernel/bio.c:93`） 调用 `bget` 获得指定扇区的缓冲区（` kernel/bio.c:97`）。如果需要从磁盘读数据，`bread` 会在返回缓冲区前调用 `virtio_disk_rw`。

`Bget`（`kernel/bio.c:59`）扫描缓冲区链表，通过给定的设备号和扇区号找到对应的缓冲区（`kernel/bio.c:65-73`）。如果存在这样一个缓冲区，会通过` sleep-lock`对其加锁，然后返回该缓存区。

如果所请求的扇区还未被缓冲，`bget` 必须分配一个缓冲区，可能是重用某一个缓冲区。它再次扫描缓冲区列表，寻找一块不是busy状态的块（`b->refcnt = 0`），所有此状态的块均可被重用。`bget` 修改这个块的元数据来记录新的设备号和扇区号，并且通过` sleep-lock`加锁。需要注意的是，同时对字段`valid`进行设置`b->valid = 0`，用来保证 `bread` 会用磁盘的内容来填充缓冲区，而不是继续使用块之前的内容。

为了保证读取磁盘扇区时可以看到写入动作，每个磁盘扇区最多有一个缓冲区，并且通过缓冲区上的锁进行同步。 在第一个循环检查块是否缓存，第二个循环缓存该扇区（`kernel/bio.c:66-88`）中，xv6的文件系统通过` bache.lock` 来确保数据连续不变。 这会导致检查块是否存在以及（如果不存在）指定缓冲区来保存块的操作是原子的。

因为`b->refcnt`不等于0保证了同一个缓存区不会同时指向不同block，因此对`bget`来说，在`bcache.lock`的竞争区外申请 `sleep-lock` 锁是线程安全的。`sleep-lock`保证了对缓存区读写的原子性，`bcache.lock`保证了block到磁盘映射的原子性。

如果所有的缓冲区都处于忙碌状态，那么就出问题了，`bget` 就会报错。不过一个更优雅的响应是进入睡眠状态，直到有一块缓冲区变为空闲状态。虽然这有可能导致死锁。

一旦 `bread` 给自己的调用者返回了一块缓冲区，调用者就独占了这块缓冲区。如果调用者写了数据，他必须调用 `bwrite`在释放缓冲区之前将修改了的数据写入磁盘，`bwrite` 调用 `virtio_disk_rw` 将缓冲区的内容写到磁盘。

当调用者使用完了一块缓冲区，他必须调用 `brelse` 来释放它，（关于 `brelse` 这个名字，它是 `b-release` 的缩写，它源自 Unix 并且在 BSD，Linux 和 Solaris 中被广泛使用）。`brelse`（`kernel/bio.c:117`）将一块缓冲区移动到链表的头部（`kernel/bio.c:128-133`）。移动缓冲区的作用在于使得链表按照最近被使用的情况排序，链表中的第一块是最近被用的，最后一块是最早被用的。`bget` 中的两个循环就利用这一点：寻找已经存在的缓冲区在最坏情况下必须遍历整个链表，但是由于数据局部性，从最近使用的块开始找（从 `bcache.head` 开始，然后用 `next` 指针遍历）会大大减少扫描的时间。反之，找一块可重用的缓冲区是从链表头向前找，相当于从尾部往头部通过 `prev` 指针遍历，从而找到的就是最近不被使用的块。

