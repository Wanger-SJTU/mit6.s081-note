
本部分是 page table的相关实验。在介绍相关实验以及解答之前，先解释一下xv6的内存分配机制。

## 内存管理机制

### 页表
为了保证各个进程的独立性，相互之间的内存独立性，操作系统引入了页表（page table）。之后，CPU执行命令时，读取的地址就是一个虚拟地址，由内存管理单元（MMU，Memory Management Unit）负责将其翻译为一个虚拟地址。

![](asserts/mmu.png)

为了支持MMU的翻译工作，就需要一个映射表来记录虚拟地址到真实地址的映射关系。这个表单完成了VA->PA的映射关系。实际上这个表单是存在内存中的，MMU负责从内存中读取这个表单。对每个地址创建一条映射表单很不划算，这会导致大量的内存占用，实际中是为每个page创建一条条目。为了能够找到对应的地址，虚拟地址的结构分为两部分，

![](asserts/va-pa.png)

而RISC-V中，一个page是4KB，也就是 4096 Bytes。这个大小非常常见，几乎所有的处理器都使用4KB大小的 page或者支持4KB大小的page。

有关RISC-V的一件有意思的事情是，虚拟内存地址都是64bit，这也说的通，因为RISC-V的寄存器是64bit的。但是实际上，在我们使用的RSIC-V处理器上，并不是所有的64bit都被使用了，也就是说高25bit并没有被使用。这样的结果是限制了虚拟内存地址的数量，虚拟内存地址的数量现在只有2^39个，大概是512GB。当然，如果必要的话，最新的处理器或许可以支持更大的地址空间，只需要将未使用的25bit拿出来做为虚拟内存地址的一部分即可。

在RISC-V中，物理内存地址是56bit。所以物理内存可以大于单个虚拟内存地址空间，但是也最多到2^56。其中44bit是物理page号（PPN，Physical Page Number），剩下12bit是offset完全继承自虚拟内存地址（也就是地址转换时，只需要将虚拟内存中的27bit翻译成物理内存中的44bit的page号，剩下的12bitoffset直接拷贝过来即可）。


现在来看，page table大小为`2^27`, 以`64 bit`系统为例，这就需要 2^27*64/8/1024/1024=1024MB大小的物理内存。

实际上，硬件并不是按照这里的方式来存储 page table。从概念上来说，你可以认为page table是从0到2^27，但是实际上并不是这样。实际中，page table是一个多级的结构。下图是一个真正的RISC-V page table结构和硬件实现。

![](asserts/multi-page.png)

查找过程为：

首先从satp中读取第一集页表的位置，加载。根据L2的索引，找到下一级L1表单地址，加载到内存，根据L1的索引，查找L0表单地址，根据LO索引加上offset计算到物理内存地址。

与直接编码相比，这种方法，可以映射到更广的空间，也无需对所有页表建立索引。

