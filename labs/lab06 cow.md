

Copy On Write这项技术了，原理也很简单：

- fork创建出的子进程，与父进程共享内存空间。如果子进程不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程，这样创建子进程的速度就很快了！(不用复制，直接引用父进程的物理空间)。
- 并且如果在fork函数返回之后，子进程第一时间exec一个新的可执行映像，那么也不会浪费时间和内存空间了。

Copy On Write技术实现原理：

fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。

### hint
- 修改 uvmcopy函数，完成了父进程向子进程复制操作，此处不直接分配新物理页，而是去掉这个地址的PTE_W标志。
- 修改 usertrap函数，处理相应的中断向量，发生COW的page fault时，通过kalloc分配新的物理页，复制原有page的内容到新page，恢复该页的PTE_W标志位。
- 确保每个PTE没有引用时，才释放内存。可以通过引用计数来实现。kalloc时为1，fork时+1，为0时kfree释放该PTE。
- 引用数组在kinit中初始化，做好物理索引。
- 修改 copyout的实现，满足cow要求


## 尝试解决思路

1. 开辟一个数组，记录每个物理页的引用计数
    - 相关函数有，数组初始化、增加引用、减少引用、获取当前引用数目 (kalloc.c defs.h)
    - 增加一个宏定义 物理地址转为数组下标 (riscv.h)
    - 需要加锁保护，因为所有进程共享 
2. 实现细节
    - 在kinit中初始化引用数组，在kalloc中引用+1， kfree中引用-1，引用为0时释放内存。
    - kinit中调用了一次freerange，会减小一次内存引用，导致引用变成-1，需要+1
    - PTE增加一个PTE_COW的标志位。（riscv。h）
    - uvmcopy 需要修改一下，原来是新分配内存，这里改为cow的方式。取消原来的申请内存的方式，更改PTE标志位（增加COW标志位，去掉PTE_W),引用计数+1，
    - usertrap中处理相应的page_fault,分配新内存，更改引用计数，
    - cow_alloc封装一下。
    - copyout 中调用cow——alloc

# cow 解决思路以及需要注意的点


注意的点

- PTE复用
- PTE释放
- PTE引用计数